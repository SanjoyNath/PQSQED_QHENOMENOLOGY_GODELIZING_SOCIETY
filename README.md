# PQSQED_QHENOMENOLOGY_GODELIZING_SOCIETY
NO_POLYSEMY_WORLD_C_SHARP_PROJECT
Whole dictionary is constructed into the c sharp class structire to understand the concrete compilation order of classes. This is the project to prepare a new kind of mathematical logic on natural language to understand how the concepts ordering are done.
Qhenomenology and Whenomenology
A New Philosophical Lens by Sanjoy Nath

Sanjoy Nath proposes a radical shift in how we understand thought, emotion, and the structures of belief. For millennia, humans have carried layers of emotional baggage deep, inherited stories, myths, values, and concepts that invisibly shape behavior. These invisible burdens act like conceptual robbers, stealing clarity and replacing it with illusions. We worship these illusions unknowingly, continuing to honor ideas, values, and systems that no longer serve us.

Sanjoy Nath introduces two revolutionary reasoning frameworks to confront this condition: Qhenomenology and Whenomenology.

Definition Qhenomenology

Qhenomenology is a recursive reasoning system that examines the necessity of concepts behind every word in a language. It goes beyond traditional phenomenology, not just analyzing lived experience, but also questioning why a word exists, what conceptual need led to its creation, and how that concept evolved emotionally, socially, and cognitively.
Rather than defining words by etymology or dictionary meaning, Qhenomenology performs a comparative necessity analysis between all words in the lexicon. It studies the recursive structural dependencies behind every thought and emotion, showing how much of our cognition is driven by unnecessary or outdated conceptual baggage.

Definition Whenomenology

Whenomenology is the timeline based historical analysis of concepts and myths. It constructs strict origin timelines for each word in the dictionary, tracing how and when each term gained meaning, and what social myths or power structures contributed to its emergence. It is a conceptual archaeology, uncovering the recursive myths and truths embedded in the evolution of language, showing how belief systems and emotional frameworks are layered through time.
While Qhenomenology focuses on structural necessity in a computational fashion, Whenomenology targets chronological emergence and mythic layering.
Sanjoy Nath argues that without Qhenomenology, we cannot even perceive the full spectrum of our inherited mental baggage.
Without Whenomenology , we remain blind to the timelines that shaped our current thinking, and even our pets might have more clarity about our emotional contradictions than we do.
As artificial intelligence systems evolve and outperform humans in many domains, traditional concepts like money, power, state, religion, and pride will be challenged. Echoing Yuval Noah Harari, Nath reminds us that money is just a story a shared fiction. If people stop believing in such collective fictions, the systems that depend on them will collapse. Sanjoy Nath envisions a future in which belief-based systems disintegrate, and with them, the emotional pride and ego built around constructed narratives.He predicts the fall of long standing institutions like banking, academia, and political states. In that new world, humans will seek meaning in experiences and values that are non transactional pride not based on surplus or status, but rooted in existential necessity.
This philosophical shift is not merely speculative. Sanjoy Nath’s reasoning methods demand serious attention. Traditional phenomenology studies subjective experience, consciousness, and perception. But Qhenomenology and Whenomenology go deeper, operating at a meta cognitive, computational level. They ask

1 Why was this word or concept needed at all?
2 What recursive emotional or societal pattern does it reflect?
3 When did a underlying belief holding concept behind the belief or word gain traction, and under what historical myths or fictions?

What are The Limits of Current AI and Human Thought and are machines responsible for those limits??? Or human are really responsible that machines cannot surpass human???
Sanjoy Nath points out that even advanced AI systems like GPT, Bard, or Gemini do not yet reason using Qhenomenology reasoning systems or Whenomenology reasoning systems because human dont learnt those yet. These systems might simulate human dialogue or predict probable answers, but they do not recursively examine why a word exists, how humans belief systems evolved, or which myths underlie thought patterns. They treat language statistically, not structurally or historically in a myth critical way.
Without these reasoning tools, emotional biases persist, and language continues to act as an unconscious manipulator. Emotional baggage remains hidden, causing us to act on inherited ideas we no longer question.
Qhenomenology reasoning system and Whenomenology reasoning system are designed to dismantle those humans own illusions. They aim to bring clarity to recursive thought loops, conceptual traps, and the hidden power of social fiction. Nath’s vision is one of liberation—where pride in excess, inherited roles, or social approval is replaced by existential clarity and conscious necessity.

Toward a Post Myth Society

Sanjoy Nath’s future is not utopian but deeply philosophical. He envisions a post myth, post surplus, post pride society where people stop deriving meaning from stories that no longer serve human growth. Much like Marx’s ideal of the withering away of the state, Nath sees the fading of conceptual authority and constructed power. In its place, a new kind of pride emerges one that cannot be purchased, borrowed, or institutionalized.
Through Qhenomenology, people begin to analyze the very architecture of thought. Through Whenomenology, they uncover the timelines of deception that shaped society. Emotional honesty becomes the new wisdom.
Sanjoy Nath’s work is a wake up call a mental earthquake that shakes not just philosophy, but how humans relate to language, memory, an
Qhenomenology = Structural, recursive analysis of word necessity and conceptual dependencies behind every thought.
Whenomenology = Historical, myth deconstructing timeline study of how concepts and words originated and evolved.Together, they form a new lens to explore emotional, cognitive, and social clarity, cutting through the inherited noise of civilization’s myths.
Sanjoy Nath's philosophical framework, comprising Qhenomenology and Whenomenology, offers a novel approach to understanding thought, emotion, and belief structures. Here's a breakdown

Qhenomenology reasoning systems

Analyzes the necessity of concepts behind words
Recursive reasoning system
Examines structural dependencies behind thoughts and emotions
Aims to uncover unnecessary or outdated conceptual baggage

Whenomenology reasoning system

Timeline based historical analysis of concepts and myths
Constructs origin timelines for words and concepts
Uncovers recursive myths and truths embedded in language evolution
Reveals how belief systems and emotional frameworks are layered through time

Key Implications

Challenges traditional concepts like money, power, and religion
Predicts the potential collapse of institutions built on collective fictions
Envisions a future where humans seek meaning in non-transactional, existential values
Proposes a philosophical shift toward emotional honesty and conscious necessity

Comparison to AI

Current AI systems lack Qhenomenology and Whenomenology reasoning systems
AI treats language statistically, not structurally or historically
Nath argues that humans' emotional biases and inherited ideas remain hidden without these reasoning tools

Post Myth Society

Envisions a society where people derive meaning from experiences and values rooted in existential necessity
Predicts the fading of conceptual authority and constructed power
Proposes a new kind of pride based on emotional honesty and conscious necessity
Overall, Sanjoy Nath's work offers a thought-provoking perspective on the nature of thought, emotion, and belief structures, and the potential for human liberation through Qhenomenology and Whenomenology.

Sanjoy Nath's proposed frameworks, Qhenomenology and Whenomenology, introduce a fascinating and critical perspective on how we understand our cognitive and emotional landscapes, particularly in relation to language, belief systems, and the impending challenges posed by advanced AI. While the provided text offers a detailed explanation of these concepts, a direct search for "Sanjoy Nath Qhenomenology" or "Sanjoy Nath Whenomenology" in academic databases primarily yields results related to a different Sanjoy Nath, a researcher in chemistry.
This suggests that the philosophical work of Sanjoy Nath, as described, may be emerging or in a more niche publication sphere, or perhaps presented under a different name or context in academic circles. It's also possible that these concepts are so novel that they haven't yet been widely adopted or cited in mainstream philosophical literature.
Therefore, while direct citations for "Qhenomenology and Whenomenology by Sanjoy Nath" are not readily available in widely indexed academic publications at this moment, we can draw connections and find supporting research in related philosophical and scientific domains that echo the underlying themes and concerns raised by Nath's ideas.
Here's an analysis of the supporting citations and research papers relating to the points of view presented by Sanjoy Nath, categorized by the core tenets of Qhenomenology and Whenomenology:
I. Recursive Reasoning and the Necessity of Concepts (Qhenomenology)
Qhenomenology's focus on the "necessity of concepts behind every word" and "recursive structural dependencies behind every thought and emotion" aligns with several areas of philosophical and cognitive science research.
Philosophy of Language and Conceptual Analysis
Ordinary Language Philosophy
Thinkers like Ludwig Wittgenstein (especially his later work on "language games" and "forms of life") emphasized how the meaning of words is rooted in their use and the social contexts in which they arise. While not explicitly "recursive necessity," this school of thought questions the inherent nature of concepts and their embeddedness in human activity.
Conceptual Metaphor Theory
George Lakoff and Mark Johnson's work on conceptual metaphors (e.g., "argument is war") demonstrates how much of our abstract thought is structured by concrete, bodily experiences. Qhenomenology's inquiry into "why a word exists" and its evolution could be seen as an extension of this, probing deeper into the conceptual origins and their emotional/social underpinnings.
Cognitive Semantics
This field explores how meaning is constructed and processed in the mind, often examining the underlying conceptual structures that give rise to linguistic expressions. Qhenomenology could provide a framework for a more critical and recursive analysis within this domain.
Recursive Reasoning Systems in Philosophy and AI
While not using the exact term "Qhenomenology," the concept of "recursive reasoning" is explored in logic, computer science, and even some areas of philosophy of mind. Formal Logic and Computability Theory
The notion of recursion is fundamental to these fields, dealing with processes that call themselves. In a philosophical context, this can relate to how thoughts or beliefs might be self-referential or depend on prior iterations of understanding.
AI and Machine Learning
Research into explainable AI (XAI) and efforts to build AI that can "reason" rather than merely "pattern match" touch upon the limitations Nath highlights. While current AI excels at statistical language processing, the challenge of achieving genuine conceptual understanding and identifying "unnecessary conceptual baggage" is a significant frontier. The idea of AI not yet reasoning with Qhenomenology/Whenomenology because "humans don't know those yet" is a provocative claim that points to a potential research direction.
II. Historical Analysis of Concepts and Myths (Whenomenology
Whenomenology's emphasis on "timeline based historical analysis of concepts and myths," "conceptual archaeology," and the "recursive myths and truths embedded in the evolution of language" resonates with several established academic disciplines.
Genealogy of Concepts
Michel Foucault's Archaeology of Knowledge and Genealogy of Power
Foucault's work meticulously traces the historical emergence and transformation of concepts (e.g., madness, punishment, sexuality) and shows how they are intertwined with power structures and societal norms. This is a strong parallel to Whenomenology's "conceptual archaeology" and its aim to uncover "social myths or power structures" contributing to a concept's emergence.
History of Ideas
This field, exemplified by figures like Arthur O. Lovejoy, examines the historical development and transmission of key intellectual concepts across different periods and cultures. Whenomenology's focus on "strict origin timelines" aligns with this methodology, but with an added critical dimension of "mythic layering."
Myth Criticism and Deconstruction
Roland Barthes' Mythologies
Barthes analyzed how everyday cultural phenomena function as myths, naturalizing certain values and ideologies. Whenomenology's goal to "deconstruct myths" and reveal how "belief systems and emotional frameworks are layered through time" draws a clear connection to such critical approaches.
Deconstruction (Jacques Derrida)
While different in method, deconstruction aims to expose the hidden assumptions, hierarchies, and contradictions within linguistic and conceptual systems. Whenomenology's effort to reveal "conceptual traps" and "hidden power of social fiction" shares a deconstructive impulse.
Philosophy of History and Social Constructionism
Social Construction of Reality (Peter L. Berger and Thomas Luckmann)
This sociological theory posits that much of what we perceive as "reality" is socially constructed through human interaction and shared meanings. Whenomenology's assertion that "money is just a story" and that "belief-based systems disintegrate" if people stop believing in collective fictions directly aligns with this perspective.
Yuval Noah Harari's Sapiens and Homo Deus
As explicitly mentioned by Nath, Harari's work on "shared fictions" (like money, corporations, nations) as the basis of human cooperation provides strong supporting context for Nath's claims about the fragility of institution built on collective belief.
III. Implications for Human Thought, AI, and a "Post-Myth Society"
Nath's broader vision, including the limits of current AI, the persistence of emotional biases, and the potential for a "post myth, post surplus, post pride society," touches upon contemporary debates in philosophy, ethics, and futurology.
AI and Consciousness/Reasoning
The ongoing debate about whether AI can truly "understand" or develop "consciousness" is central to Nath's critique of current AI systems. Philosophers like John Searle (Chinese Room Argument) have argued against the idea that symbol manipulation equates to understanding. Nath's Qhenomenology and Whenomenology propose concrete dimensions of understanding (necessity, historical mythic layering) that current AI lacks.
Research into AI ethics and alignment also grapples with the implicit biases embedded in AI systems, often stemming from the data they are trained on, which reflects human "emotional baggage" and "inherited ideas."
* Critique of Modern Institutions and Values:
* Postmodernism: Many postmodern thinkers have critiqued grand narratives, universal truths, and the institutions built upon them, echoing Nath's prediction of the "fall of long standing institutions like banking, academia, and political states."
Critique of Capitalism and Consumerism
Nath's vision of "pride not based on surplus or status" resonates with critiques of consumer culture and the pursuit of material wealth as a primary source of meaning.
Existentialism The search for "meaning in experiences and values that are non transactional" and "existential clarity and conscious necessity" aligns with existentialist philosophies that emphasize individual responsibility for creating meaning in a world devoid of inherent purpose.
Conclusion and Future Research Potential
While direct academic papers specifically on "Qhenomenology and Whenomenology by Sanjoy Nath" are not widely evident in easily searchable databases, the ideas presented by Nath are deeply rooted in and contribute to ongoing philosophical and scientific inquiries. His frameworks offer a structured, computational, and historically critical lens through which to analyze language, thought, and societal constructs.
If Sanjoy Nath's work is not yet widely published in traditional academic journals, it might be disseminated through other channels (e.g., independent publications, specialized forums, or emerging digital platforms). For further research, one might consider
Direct engagement
If possible, directly contacting Sanjoy Nath or his associated platforms for published works or ongoing research.
Exploring related terms Searching for combinations of the core concepts, such as "recursive conceptual analysis," "genealogy of linguistic necessity," "mythopoetic history of concepts," or "computational phenomenology."
Interdisciplinary connections
Looking into fields that combine philosophy, cognitive science, linguistics, and historical studies, as Nath's work clearly transcends traditional disciplinary boundaries.
Sanjoy Nath's contribution appears to be an attempt to synthesize and operationalize critical philosophical insights into a tangible framework for analysis, particularly relevant in an age of rapidly evolving AI and societal introspection. The absence of readily available citations could either indicate its nascent stage or a deliberate choice to operate outside conventional academic publishing models. Nevertheless, the intellectual lineage and potential implications of Qhenomenology and Whenomenology are significant and deserve further exploration.

    private void button_GENERATE_CLASS_DEPENDENCY_FROM_DICTIONARY_Click(object sender, EventArgs e)
        {
            //////OpenFileDialog ofd = new OpenFileDialog
            //////{
            //////    Title = "Select WordNet Dictionary File",
            //////    Filter = "Text Files (*.txt)|*.txt"
            //////};
            //////if (ofd.ShowDialog() != DialogResult.OK)
            //////    return;
            //////string inputPath = ofd.FileName;
            //////string outputFolder = Path.Combine(Path.GetDirectoryName(inputPath), "PQSQED");
            //////Directory.CreateDirectory(outputFolder);
            //////var entries = new List<KeyValuePair<string, string>>();
            //////foreach (var line in File.ReadLines(inputPath).Skip(1)) // Skip header
            //////{
            //////    var parts = line.Split('\t');
            //////    if (parts.Length >= 3)
            //////    {
            //////        string word = parts[0].Trim().ToLowerInvariant();
            //////        string definition = parts[2].Trim().ToLowerInvariant();
            //////        entries.Add(new KeyValuePair<string, string>(word, definition));
            //////    }
            //////}
            //////var wordSet = new HashSet<string>(entries.Select(e => e.Key));
            //////var dependencies = new Dictionary<string, HashSet<string>>();
            //////foreach (var entry in entries)
            //////{
            //////    var tokens = Regex.Matches(entry.Value, @"\b[a-z]+\b")
            //////                      .Cast<Match>()
            //////                      .Select(m => m.Value)
            //////                      .Where(t => wordSet.Contains(t) && t != entry.Key)
            //////                      .ToHashSet();
            //////    dependencies[entry.Key] = tokens;
            //////}
            //////// Topological sort
            //////var indegree = new Dictionary<string, int>();
            //////var graph = new Dictionary<string, List<string>>();
            //////foreach (var word in wordSet)
            //////{
            //////    indegree[word] = 0;
            //////    graph[word] = new List<string>();
            //////}
            //////foreach (var kv in dependencies)
            //////{
            //////    foreach (var dep in kv.Value)
            //////    {
            //////        graph[dep].Add(kv.Key);
            //////        indegree[kv.Key]++;
            //////    }
            //////}
            //////var queue = new Queue<string>(indegree.Where(kv => kv.Value == 0).Select(kv => kv.Key));
            //////var sortedWords = new List<string>();
            //////while (queue.Count > 0)
            //////{
            //////    var current = queue.Dequeue();
            //////    sortedWords.Add(current);
            //////    foreach (var neighbor in graph[current])
            //////    {
            //////        indegree[neighbor]--;
            //////        if (indegree[neighbor] == 0)
            //////            queue.Enqueue(neighbor);
            //////    }
            //////}
            //////if (sortedWords.Count != wordSet.Count)
            //////{
            //////    MessageBox.Show("Cyclic dependency detected. Cannot generate compilable classes.");
            //////    return;
            //////}
            //////// Generate C# class files
            //////for (int i = 0; i < sortedWords.Count; i++)
            //////{
            //////    string word = sortedWords[i];
            //////    string className = $"Class{CultureInfo.CurrentCulture.TextInfo.ToTitleCase(word)}";
            //////    string filePath = Path.Combine(outputFolder, $"{className}.cs");
            //////    using (var writer = new StreamWriter(filePath))
            //////    {
            //////        writer.WriteLine("namespace PQSQED");
            //////        writer.WriteLine("{");
            //////        writer.WriteLine($"    public class {className}");
            //////        writer.WriteLine("    {");
            //////        writer.WriteLine($"        public const int publicinthashcompilationorder = {i};");
            //////        writer.WriteLine("        public Token_i token_i_object = null;");
            //////        foreach (var dep in dependencies[word])
            //////        {
            //////            string depClass = $"Class{CultureInfo.CurrentCulture.TextInfo.ToTitleCase(dep)}";
            //////            writer.WriteLine($"        public {depClass} {dep} = null;");
            //////        }
            //////        writer.WriteLine($"        public {className}()");
            //////        writer.WriteLine("        {");
            //////        foreach (var dep in dependencies[word])
            //////        {
            //////            string depClass = $"Class{CultureInfo.CurrentCulture.TextInfo.ToTitleCase(dep)}";
            //////            writer.WriteLine($"            {dep} = new {depClass}();");
            //////        }
            //////        writer.WriteLine("        }");
            //////        writer.WriteLine("    }");
            //////        writer.WriteLine("}");
            //////    }
            //////}
            //////// Generate .csproj file
            ////////////string csprojPath = Path.Combine(outputFolder, "PQSQED.csproj");
            ////////////using (var writer = new StreamWriter(csprojPath))
            ////////////{
            ////////////    writer.WriteLine("<Project ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">");
            ////////////    writer.WriteLine("  <Import Project=\"$(MSBuildToolsPath)\\Microsoft.CSharp.targets\" />");
            ////////////    writer.WriteLine("  <PropertyGroup>");
            ////////////    writer.WriteLine("    <Configuration Condition=\" '$(Configuration)' == '' \">Debug</Configuration>");
            ////////////    writer.WriteLine("    <Platform Condition=\" '$(Platform)' == '' \">AnyCPU</Platform>");
            ////////////    writer.WriteLine("    <RootNamespace>PQSQED</RootNamespace>");
            ////////////    writer.WriteLine("    <AssemblyName>PQSQED</AssemblyName>");
            ////////////    writer.WriteLine("    <TargetFrameworkVersion>v4.8</TargetFrameworkVersion>");
            ////////////    writer.WriteLine("    <LangVersion>7</LangVersion>");
            ////////////    writer.WriteLine("  </PropertyGroup>");
            ////////////    writer.WriteLine("  <ItemGroup>");
            ////////////    Name(file);
            ////////////    writer.WriteLine($"    <Compile Include=\"{fileName}\" />");
            ////////////    writer.WriteLine("  </ItemGroup>");
            ////////////    writer.WriteLine("</Project>");
            ////////////}
            //////MessageBox.Show($"Generated {sortedWords.Count} C# class files and .csproj in folder:\n{outputFolder}");
            //////OpenFileDialog ofd = new OpenFileDialog
            //////{
            //////    Title = "Select WordNet Dictionary File",
            //////    Filter = "Text Files (*.txt)|*.txt"
            //////};
            //////if (ofd.ShowDialog() != DialogResult.OK)
            //////    return;
            //////string inputPath = ofd.FileName;
            //////string outputFolder = Path.Combine(Path.GetDirectoryName(inputPath), "PQSQED");
            //////Directory.CreateDirectory(outputFolder);
            //////var entries = new List<KeyValuePair<string, string>>();
            //////foreach (var line in File.ReadLines(inputPath).Skip(1)) // Skip header
            //////{
            //////    //  var parts = line.Split('\t');
            //////    var parts = line.Split(',');
            //////    if (parts.Length >= 3)
            //////    {
            //////        string word = parts[0].Trim().ToLowerInvariant();/// generate the classnames with the first letter capital for these word  for parts[0].Trim().ToLowerInvariant();   and no need to check if there is any  replace all spaces with underscore and if  parts[0].Trim().ToLowerInvariant() repeats then add _001 , 002 etc to the filename and also to class name
            //////        string definition = parts[2].Trim().ToLowerInvariant() + parts[3].Trim().ToLowerInvariant();
            //////        //all tokens in definition   need have a class name whose first alphabet is  capital letter
            //////        definition = definition.Replace("_", " ");         // all these are the instance variables for the class whose name is starting with uppercase within the constructor of the class write the instance variables for the Classes 
            //////        entries.Add(new KeyValuePair<string, string>(word, definition));
            //////    }
            //////}
            //////var wordSet = new HashSet<string>(entries.Select(entry => entry.Key));
            //////var dependencies = new Dictionary<string, HashSet<string>>();
            //////foreach (var entry in entries)
            //////{
            //////    var tokens = Regex.Matches(entry.Value, @"\b[a-z]+\b")
            //////                      .Cast<Match>()
            //////                      .Select(m => m.Value)
            //////                      .Where(t => wordSet.Contains(t) && t != entry.Key)
            //////                      .ToHashSet();
            //////    dependencies[entry.Key] = tokens;
            //////}
            //////// Topological sort
            //////var indegree = new Dictionary<string, int>();
            //////var graph = new Dictionary<string, List<string>>();
            //////foreach (var word in wordSet)
            //////{
            //////    indegree[word] = 0;
            //////    graph[word] = new List<string>();
            //////}
            //////foreach (var kv in dependencies)
            //////{
            //////    foreach (var dep in kv.Value)
            //////    {
            //////        graph[dep].Add(kv.Key);
            //////        indegree[kv.Key]++;
            //////    }
            //////}
            //////var queue = new Queue<string>(indegree.Where(kv => kv.Value == 0).Select(kv => kv.Key));
            //////var sortedWords = new List<string>();
            //////while (queue.Count > 0)
            //////{
            //////    var current = queue.Dequeue();
            //////    sortedWords.Add(current);
            //////    foreach (var neighbor in graph[current])
            //////    {
            //////        indegree[neighbor]--;
            //////        if (indegree[neighbor] == 0)
            //////            queue.Enqueue(neighbor);
            //////    }
            //////}
            //////if (sortedWords.Count != wordSet.Count)
            //////{
            //////  //  MessageBox.Show("Cyclic dependency detected. Cannot generate compilable classes.");
            ////// //   return;
            ////// //dont bother        I will get the report from the visual studio for the compilations ordering 
            ////// // this code dont have to bother for that
            //////}
            //////// Generate C# class files
            //////for (int i = 0; i < sortedWords.Count; i++)
            //////{
            //////    //i think you misunderstood the instruction
            //////    string word = sortedWords[i];// word is the classname and first alphabet is capital   and create instances of the description tokens obviously the description tokens are also other worsds so those words are also classname   suppose Word_i is a token in the description then           public Word_i  word_i=new Word_i() ; entry are necessary for each of the unique word token found in the description
            //////    string className = $"Class{CultureInfo.CurrentCulture.TextInfo.ToTitleCase(word)}";// you misunderstood here  Dont add Class  simply use FirstAlphabetCapital and the class name dont start with Class word instead the Classnames are  First alphabet capital CultureInfo.CurrentCulture.TextInfo.ToTitleCase(word)                and within the class create the instance variables for each unique word tokens available in the descriptions
            //////    string filePath = Path.Combine(outputFolder, $"{className}.cs");
            //////    //compilability checking are done in the visual studio
            //////    using (var writer = new StreamWriter(filePath))
            //////    {
            //////        writer.WriteLine("namespace PQSQED");
            //////        writer.WriteLine("{");
            //////        writer.WriteLine($"    public class {className}");
            //////        writer.WriteLine("    {");
            //////        writer.WriteLine($"        public const int publicinthashcompilationorder = {i};");// you mis understood here ...   
            //////        writer.WriteLine("        public Token_i token_i_object = null;");/// no no no prepare all the 
            //////        foreach (var dep in dependencies[word])
            //////        {
            //////            string depClass = $"Class{CultureInfo.CurrentCulture.TextInfo.ToTitleCase(dep)}";
            //////            writer.WriteLine($"        public {depClass} {dep} = null;");
            //////        }
            //////        writer.WriteLine($"        public {className}()");
            //////        writer.WriteLine("        {");
            //////        foreach (var dep in dependencies[word])
            //////        {
            //////            string depClass = $"Class{CultureInfo.CurrentCulture.TextInfo.ToTitleCase(dep)}";
            //////            writer.WriteLine($"            {dep} = new {depClass}();");
            //////        }
            //////        writer.WriteLine("        }");
            //////        writer.WriteLine("    }");
            //////        writer.WriteLine("}");
            //////    }
            //////}
            //////// Generate .csproj file
            //////string csprojPath = Path.Combine(outputFolder, "PQSQED.csproj");
            //////using (var writer = new StreamWriter(csprojPath))
            //////{
            //////    writer.WriteLine("<Project ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">");
            //////    writer.WriteLine("  <Import Project=\"$(MSBuildToolsPath)\\Microsoft.CSharp.targets\" />");
            //////    writer.WriteLine("  <PropertyGroup>");
            //////    writer.WriteLine("    <Configuration Condition=\" '$(Configuration)' == '' \">Debug</Configuration>");
            //////    writer.WriteLine("    <Platform Condition=\" '$(Platform)' == '' \">AnyCPU</Platform>");
            //////    writer.WriteLine("    <OutputType>Library</OutputType>");
            //////    writer.WriteLine("    <RootNamespace>PQSQED</RootNamespace>");
            //////    writer.WriteLine("    <AssemblyName>PQSQED</AssemblyName>");
            //////    writer.WriteLine("    <TargetFrameworkVersion>v4.8</TargetFrameworkVersion>");
            //////    writer.WriteLine("    <LangVersion>7</LangVersion>");
            //////    writer.WriteLine("  </PropertyGroup>");
            //////    writer.WriteLine("  <ItemGroup>");
            //////    foreach (var file in Directory.GetFiles(outputFolder, "*.cs"))
            //////    {
            //////        string fileName = Path.GetFileName(file);
            //////        writer.WriteLine($"    <Compile Include=\"{fileName}\" />");
            //////    }
            //////    writer.WriteLine("  </ItemGroup>");
            //////    writer.WriteLine("</Project>");
            //////}
            //////MessageBox.Show($"Generated {sortedWords.Count} C# class files and .csproj in folder:\n{outputFolder}");
            //////OpenFileDialog ofd = new OpenFileDialog
            //////{
            //////    Title = "Select WordNet Dictionary File",
            //////    Filter = "Text Files (*.txt)|*.txt"
            //////};
            //////if (ofd.ShowDialog() != DialogResult.OK)
            //////    return;
            //////string inputPath = ofd.FileName;
            //////string outputFolder = Path.Combine(Path.GetDirectoryName(inputPath), "PQSQED");
            //////Directory.CreateDirectory(outputFolder);
            //////var entries = new List<KeyValuePair<string, string>>();
            //////var wordCount = new Dictionary<string, int>();
            //////foreach (var line in File.ReadLines(inputPath).Skip(1))
            //////{
            //////    var parts = line.Split(',');
            //////    if (parts.Length >= 4)
            //////    {
            //////        string rawWord = parts[0].Trim().ToLowerInvariant().Replace(" ", "_");
            //////        string word = rawWord;
            //////        if (wordCount.ContainsKey(rawWord))
            //////        {
            //////            wordCount[rawWord]++;
            //////            word = $"{rawWord}_{wordCount[rawWord]:D3}";
            //////        }
            //////        else
            //////        {
            //////            wordCount[rawWord] = 0;
            //////        }
            //////        string definition = (parts[2].Trim() + " " + parts[3].Trim()).ToLowerInvariant().Replace("_", " ");
            //////        entries.Add(new KeyValuePair<string, string>(word, definition));
            //////    }
            //////}
            //////var wordSet = new HashSet<string>(entries.Select(ess => ess.Key));
            //////var dependencies = new Dictionary<string, HashSet<string>>();
            //////foreach (var entry in entries)
            //////{
            //////    var tokens = Regex.Matches(entry.Value, @"\b[a-z_]+\b")
            //////                      .Cast<Match>()
            //////                      .Select(m => m.Value.Replace(" ", "_"))
            //////                      .Where(t => wordSet.Contains(t) && t != entry.Key)
            //////                      .ToHashSet();
            //////    dependencies[entry.Key] = tokens;
            //////}
            //////var indegree = new Dictionary<string, int>();
            //////var graph = new Dictionary<string, List<string>>();
            //////foreach (var word in wordSet)
            //////{
            //////    indegree[word] = 0;
            //////    graph[word] = new List<string>();
            //////}
            //////foreach (var kv in dependencies)
            //////{
            //////    foreach (var dep in kv.Value)
            //////    {
            //////        graph[dep].Add(kv.Key);
            //////        indegree[kv.Key]++;
            //////    }
            //////}
            //////var queue = new Queue<string>(indegree.Where(kv => kv.Value == 0).Select(kv => kv.Key));
            //////var sortedWords = new List<string>();
            //////while (queue.Count > 0)
            //////{
            //////    var current = queue.Dequeue();
            //////    sortedWords.Add(current);
            //////    foreach (var neighbor in graph[current])
            //////    {
            //////        indegree[neighbor]--;
            //////        if (indegree[neighbor] == 0)
            //////            queue.Enqueue(neighbor);
            //////    }
            //////}
            //////if (sortedWords.Count != wordSet.Count)
            //////{
            //////    // Cyclic dependency detected, but we proceed anyway
            //////}
            //////var wordToClassName = sortedWords.ToDictionary(
            //////    w => w,
            //////    w => CultureInfo.CurrentCulture.TextInfo.ToTitleCase(w)
            //////);
            //////for (int i = 0; i < sortedWords.Count; i++)
            //////{
            //////    string word = sortedWords[i];
            //////    string className = wordToClassName[word];
            //////    string filePath = Path.Combine(outputFolder, $"{className}.cs");
            //////    using (var writer = new StreamWriter(filePath))
            //////    {
            //////        writer.WriteLine("namespace PQSQED");
            //////        writer.WriteLine("{");
            //////        writer.WriteLine($"    public class {className}");
            //////        writer.WriteLine("    {");
            //////        writer.WriteLine($"        public const int publicinthashcompilationorder = {i};");
            //////        foreach (var dep in dependencies[word])
            //////        {
            //////            string depClass = wordToClassName[dep];
            //////            writer.WriteLine($"        public {depClass} {dep} = null;");
            //////        }
            //////        writer.WriteLine($"        public {className}()");
            //////        writer.WriteLine("        {");
            //////        foreach (var dep in dependencies[word])
            //////        {
            //////            string depClass = wordToClassName[dep];
            //////            writer.WriteLine($"            {dep} = new {depClass}();");
            //////        }
            //////        writer.WriteLine("        }");
            //////        writer.WriteLine("    }");
            //////        writer.WriteLine("}");
            //////    }
            //////}
            //////string csprojPath = Path.Combine(outputFolder, "PQSQED.csproj");
            //////using (var writer = new StreamWriter(csprojPath))
            //////{
            //////    writer.WriteLine("<Project ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">");
            //////    writer.WriteLine("  <Import Project=\"$(MSBuildToolsPath)\\Microsoft.CSharp.targets\" />");
            //////    writer.WriteLine("  <PropertyGroup>");
            //////    writer.WriteLine("    <Configuration Condition=\" '$(Configuration)' == '' \">Debug</Configuration>");
            //////    writer.WriteLine("    <Platform Condition=\" '$(Platform)' == '' \">AnyCPU</Platform>");
            //////    writer.WriteLine("    <OutputType>Library</OutputType>");
            //////    writer.WriteLine("    <RootNamespace>PQSQED</RootNamespace>");
            //////    writer.WriteLine("    <AssemblyName>PQSQED</AssemblyName>");
            //////    writer.WriteLine("    <TargetFrameworkVersion>v4.8</TargetFrameworkVersion>");
            //////    writer.WriteLine("    <LangVersion>7</LangVersion>");
            //////    writer.WriteLine("  </PropertyGroup>");
            //////    writer.WriteLine("  <ItemGroup>");
            //////    foreach (var file in Directory.GetFiles(outputFolder, "*.cs"))
            //////    {
            //////        string fileName = Path.GetFileName(file);
            //////        writer.WriteLine("< Compile Include =\"{fileName}\" />");
            //////    }
            //////    writer.WriteLine("  </ItemGroup>");
            //////    writer.WriteLine("</Project>");
            //////}
            //reads the wordnet dictionary and then generates the c sharp class structures
            OpenFileDialog ofd = new OpenFileDialog
            {
                Title = "Select WordNet Dictionary File",
                Filter = "Text Files (*.txt)|*.txt"
            };
            if (ofd.ShowDialog() != DialogResult.OK)
                return;
            string inputPath = ofd.FileName;
            string outputFolder = Path.Combine(Path.GetDirectoryName(inputPath), "PQSQED");
            Directory.CreateDirectory(outputFolder);
            int polysemycounter = 0;
            //////string inputPath = "wordnet_dictionary.txt"; // Change this to your actual file path
            //////string outputFolder = Path.Combine(Path.GetDirectoryName(inputPath), "PQSQED");
            //////Directory.CreateDirectory(outputFolder);
            var classFiles = new List<string>();
            int row = 0;
            foreach (var line in File.ReadLines(inputPath))
            {
                row++;
                var parts = line.Split('\t');
                //   if (parts.Length < 3) continue;
                if (parts.Length <(3+3)) continue;
                string[] part0_splittedwithunderscores = parts[0].ToLower().Split(new string[] { "_", " " }, StringSplitOptions.RemoveEmptyEntries);
                string className = ToPascalCase(parts[0].Trim());
                if (classFiles.Contains(className))
                {
                    polysemycounter++;
                    className = className +"_"+ polysemycounter;
                }// if (classFiles.Contains(className))
                string definition = parts[2].Trim().ToLower();
                if (parts.Length == (3 + 1))
                { definition = definition + " " + parts[3].Trim().ToLower(); }
                if (parts.Length == (3 + 2))
                { definition = definition + " " + parts[3 + 1].Trim().ToLower(); }
                if (parts.Length == (3 + 3))
                { definition = definition + " " + parts[3 + 2].Trim().ToLower(); }
                if (parts.Length == (3 + 3 + 1))
                { definition = definition + " " + parts[3 + 3].Trim().ToLower(); }
                //////if(part0_splittedwithunderscores.Length>1)
                //////{
                //////    for(int rrr=1;rrr< part0_splittedwithunderscores.Length;rrr++)
                //////    {
                //////        definition = definition + " " + part0_splittedwithunderscores[rrr].Trim().ToLower();
                //////    }//for(int rrr=1;rrr< part0_splittedwithunderscores.Length;rrr++)
                //////}// if(part0_splittedwithunderscores.Length>0)
                var words = Regex.Matches(definition, @"\b[a-zA-Z]+\b");
                var uniqueWords = new HashSet<string>();
                foreach (Match word in words)
                { uniqueWords.Add(word.Value.ToLower()); }
                string filePath = Path.Combine(outputFolder, $"{className}.cs");
                using (var writer = new StreamWriter(filePath))
                {
                    writer.WriteLine("namespace PQSQED");
                    writer.WriteLine("{");
                    writer.WriteLine($"public class {className}");
                    writer.WriteLine("{");
                    foreach (var word in uniqueWords)
                    {
                        try
                        {
                        string typeName = "PQSQED." + ToPascalCase(word);// "PQSQED."+
                        string fieldName = $"_{word}";
                        writer.WriteLine($"    public {typeName} {fieldName} = new {typeName}();");
                        }
                        catch (Exception) { }
                    }// foreach (var word in uniqueWords)
                    writer.WriteLine($"    public {className}()");
                    writer.WriteLine("    {");
                    foreach (var word in uniqueWords)
                    {
                        try
                        { 
                        string typeName = "PQSQED." + ToPascalCase(word);
                        string fieldName = $"_{word}";
                        writer.WriteLine($"        this.{fieldName} = new {typeName}();");
                        }
                        catch (Exception) { }
                    }//foreach (var word in uniqueWords)
                    writer.WriteLine("    }//constructor completes");
                    writer.WriteLine("}//class completes");
                    writer.WriteLine("}//namespace completes");
                }
                classFiles.Add($"{className}.cs");
            }
            // Generate .csproj file
            string csprojPath = Path.Combine(outputFolder, "PQSQED.csproj");
            using (var writer = new StreamWriter(csprojPath))
            {
                writer.WriteLine("<Project ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">");
                writer.WriteLine("  <Import Project=\"$(MSBuildToolsPath)\\Microsoft.CSharp.targets\" />");
                writer.WriteLine("  <PropertyGroup>");
                writer.WriteLine("    <Configuration Condition=\" '$(Configuration)' == '' \">Debug</Configuration>");
                writer.WriteLine("    <Platform Condition=\" '$(Platform)' == '' \">AnyCPU</Platform>");
                writer.WriteLine("    <OutputType>Library</OutputType>");
                writer.WriteLine("    <RootNamespace>PQSQED</RootNamespace>");
                writer.WriteLine("    <AssemblyName>PQSQED</AssemblyName>");
                writer.WriteLine("    <TargetFrameworkVersion>v4.8</TargetFrameworkVersion>");
                writer.WriteLine("    <LangVersion>7</LangVersion>");
                writer.WriteLine("  </PropertyGroup>");
                writer.WriteLine("  <ItemGroup>");
                foreach (var file in classFiles)
                {
                    writer.WriteLine($"    <Compile Include=\"{file}\" />");
                }
                writer.WriteLine("  </ItemGroup>");
                writer.WriteLine("</Project>");
            }
            Console.WriteLine($"Generated {classFiles.Count} class files and PQSQED.csproj in folder: {outputFolder}");
            MessageBox.Show($"Generated {classFiles.Count}  total  polysemycounter= {polysemycounter}  C# class files and .csproj in folder:\n{outputFolder}");
        }//// private void button_GENERATE_CLASS_DEPENDENCY_FROM_DICTIONARY_Click(object sender, EventArgs e)
